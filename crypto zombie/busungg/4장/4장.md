# 컨트랙트

### 1. 함수 제어자

그동안 함수 제어자를 복습해보겠습니다.

1. 접근 제어자(visibility modifier)

   1. private
      - 컨트랙트 내부의 다름 함수들에서만 호출 될 수 있습니다.
   2. internal
      - private과 비슷하지만, 해당 컨트랙트를 상속하는 컨트랙트에서 호출될 수 있습니다.
   3. external
      - 오즉 컨트랙트 외부에서만 호출될 수 있습니다.
   4. public
      - 내외부 모두에서, 어디서든 호출될 수 있습니다.

2. 상태 제어자(state modifier)

   1. view
      - 해당 함수를 실행해도 어떤 데이터도 저장/변경되지 않음을 알려줍니다.
   2. pure
      - 해당 함수가 어떤 데이터도 블록체인에 저장하지 않을 뿐만 아니라, 블록체인으로부터 어떤 데이터도 읽지 않음을 알려줍니다.

   모두 컨트랙트 외부에서 불렸을 때 가스를 전혀 소모하지 않습니다. 하지만 다른 함수에 의해 내부적으로 호출됬을 경우에는 가스를 소모합니다.

3. 사용자 정의 제어자
   onlyOwner등이 있습니다.

제어자들은 함수 하나의 다음처럼 함께 사용될 수 있습니다.

```
function test() external view onlyOwner anotherModifier { /* ... */ }
```

### 2. payable 제어자

이더를 받을 수 있는 특별한 함수 유형입니다.
예를들어 일반적으로 웹 서버에서 API 함수를 실행할때에는, 함수 호출을 통해서 US달러를 보낼 수 없습니다 - 비트코인도 보낼 수 없습니다.  
하지만 이더리움에서는, 돈(이더), 데이터(transaction payload), 그리고 컨트랙트 코드 자체 모두 이더리움 위에 존재하기 때문에, 유저가 함수를 실행하는 동시에 컨트랙트에 돈을 지불하는 것이 가능합니다.

```
contract OnlineStore {
  function buySomething() external payable {
    // 함수 실행에 0.001이더가 보내졌는지 확실히 하기 위해 확인:
    require(msg.value == 0.001 ether);
    // 보내졌다면, 함수를 호출한 자에게 디지털 아이템을 전달하기 위한 내용 구성:
    transferThing(msg.sender);
  }
}

// msg.value 컨트랙트로 이더가 얼마나 보내졌는지 확인하는 방법
// ether는 기본적으로 포함된 단위
// 이 코드는 누군가 web3.js(DApp의 자바스크립트 프론트엔드)에서 다음과 같이 함수를 실행할 때 발생합니다.

// `OnlineStore`는 이더리움 상의 컨트랙트를 가리킨다고 가정합니다.:
OnlineStore.buySomething({from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)})
```

위의 코드에서 value 필드를 주목합시다. 자바스크립트 함수 호출에서 이 필드를 통해 ether를 얼마나 보낼지 결정합니다.  
트랜잭션을 봉투로 생각하고, 함수 호출에 전달하는 매개 변수를 우리가 써넣은 편지의 내용이라고 생각한다면, value는 봉투 안에 현금을 넣는 것과 같습니다. 그리고 편지와 돈이 모두 수령인에게 전달됩니다.

**_만약 함수가 payable로 표시되지 않았는데 위에서 본 것처럼 이더를 보내려 한다면, 함수에서 트랜잭션을 거부할 것입니다._**

### 3. 출금

이전에 컨트랙트에 이더를 보내는 방법을 배웠습니다. 그럼 이더를 보낸 다음에는 어떤 일이 일어날까요?  
우리가 컨트랙트로 이더를 보내면, 해당 컨트랙트의 이더리움 계좌에 이더가 저장되고 거기에 갇히게 됩니다. - 우리가 컨트랙트로부터 이더를 인출하는 함수를 만들지 않았다면 말입니다.

```
contract GetPaid is Ownable {
  function withdraw() external onlyOwner {
    owner.transfer(this.balance);
  }
}
// 컨트랙트에서 이더를 인출하는 함수입니다.
```

우리가 Ownable 컨트랙트를 import 했다고 가정하고 owner와 onlyOwner를 사용하고 있다는 것을 참고합니다.

우리는 transfer 함수를 사용해서 이더를 특정 주소로 전달할 수 있습니다.  
그리고 this.balance는 컨트랙트에 저장되있는 전체 잔액을 반환합니다.  
그러니 100명의 사용자가 우리의 컨트랙트에 1이더를 지불했다면, this.balance는 100이더가 될 것입니다.

우리는 transfer 함수를 써서 특정한 이더리움 주소에 돈을 보낼 수 있습니다.
예를 들어, 만약 누군가 한 아이템에 대해 초과 지불을 했다면, 이더를 msg.sender로 되돌려주는 함수를 만들 수도 있습니다.

```
uint itemFee = 0.001 ether;
msg.sender.transfer(msg.value - itemFee);
```

혹은 구매자와 판매자가 존재하는 컨트랙트에서, 판매자의 주소를 storage에 저장하고, 누군가 판매자의 아이템을 구매하면 구매자로부터 받은 요금을 그에게 전달할 수 도 있습니다.

```
seller.transfer(msg.value);
```

### 4. keccak256을 통한 난수 생성

```
// Generate a random number between 1 and 100:
uint randNonce = 0;
uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
randNonce++;
uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
```

이 예시에서는 now의 타임스탬프 값, msg.sender, 증가하는 nonce(딱 한 번만 사용되는 숫자, 즉 똑같은 입력으로 두 번 이상 동일한 해시 함수를 실행할 수 없게 함)를 받고 있습니다.
그리고서 keccak을 사용하여 이 입력들을 임의의 해시 값으로 변환하고, 변환한 해시 값을 uint로 바꾼 후, % 100을 써서 마지막 2자리 숫자만 받도록 했습니다. 이를 통해 0과 99 사이의 완전한 난수를 얻을 수 있습니다.
