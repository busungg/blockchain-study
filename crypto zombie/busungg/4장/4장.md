# 컨트랙트

### 1. 함수 제어자

그동안 함수 제어자를 복습해보겠습니다.

1. 접근 제어자(visibility modifier)

   1. private
      - 컨트랙트 내부의 다름 함수들에서만 호출 될 수 있습니다.
   2. internal
      - private과 비슷하지만, 해당 컨트랙트를 상속하는 컨트랙트에서 호출될 수 있습니다.
   3. external
      - 오즉 컨트랙트 외부에서만 호출될 수 있습니다.
   4. public
      - 내외부 모두에서, 어디서든 호출될 수 있습니다.

2. 상태 제어자(state modifier)

   1. view
      - 해당 함수를 실행해도 어떤 데이터도 저장/변경되지 않음을 알려줍니다.
   2. pure
      - 해당 함수가 어떤 데이터도 블록체인에 저장하지 않을 뿐만 아니라, 블록체인으로부터 어떤 데이터도 읽지 않음을 알려줍니다.

   모두 컨트랙트 외부에서 불렸을 때 가스를 전혀 소모하지 않습니다. 하지만 다른 함수에 의해 내부적으로 호출됬을 경우에는 가스를 소모합니다.

3. 사용자 정의 제어자
   onlyOwner등이 있습니다.

제어자들은 함수 하나의 다음처럼 함께 사용될 수 있습니다.

```
function test() external view onlyOwner anotherModifier { /* ... */ }
```

### 2. payable 제어자

이더를 받을 수 있는 특별한 함수 유형입니다.
예를들어 일반적으로 웹 서버에서 API 함수를 실행할때에는, 함수 호출을 통해서 US달러를 보낼 수 없습니다 - 비트코인도 보낼 수 없습니다.  
하지만 이더리움에서는, 돈(이더), 데이터(transaction payload), 그리고 컨트랙트 코드 자체 모두 이더리움 위에 존재하기 때문에, 유저가 함수를 실행하는 동시에 컨트랙트에 돈을 지불하는 것이 가능합니다.

```
contract OnlineStore {
  function buySomething() external payable {
    // 함수 실행에 0.001이더가 보내졌는지 확실히 하기 위해 확인:
    require(msg.value == 0.001 ether);
    // 보내졌다면, 함수를 호출한 자에게 디지털 아이템을 전달하기 위한 내용 구성:
    transferThing(msg.sender);
  }
}

// msg.value 컨트랙트로 이더가 얼마나 보내졌는지 확인하는 방법
// ether는 기본적으로 포함된 단위
// 이 코드는 누군가 web3.js(DApp의 자바스크립트 프론트엔드)에서 다음과 같이 함수를 실행할 때 발생합니다.

// `OnlineStore`는 이더리움 상의 컨트랙트를 가리킨다고 가정합니다.:
OnlineStore.buySomething({from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)})
```

위의 코드에서 value 필드를 주목합시다. 자바스크립트 함수 호출에서 이 필드를 통해 ether를 얼마나 보낼지 결정합니다.  
트랜잭션을 봉투로 생각하고, 함수 호출에 전달하는 매개 변수를 우리가 써넣은 편지의 내용이라고 생각한다면, value는 봉투 안에 현금을 넣는 것과 같습니다. 그리고 편지와 돈이 모두 수령인에게 전달됩니다.

**_만약 함수가 payable로 표시되지 않았는데 위에서 본 것처럼 이더를 보내려 한다면, 함수에서 트랜잭션을 거부할 것입니다._**

### 3. 출금

이전에 컨트랙트에 이더를 보내는 방법을 배웠습니다. 그럼 이더를 보낸 다음에는 어떤 일이 일어날까요?  
우리가 컨트랙트로 이더를 보내면, 해당 컨트랙트의 이더리움 계좌에 이더가 저장되고 거기에 갇히게 됩니다. - 우리가 컨트랙트로부터 이더를 인출하는 함수를 만들지 않았다면 말입니다.

```
contract GetPaid is Ownable {
  function withdraw() external onlyOwner {
    owner.transfer(this.balance);
  }
}
// 컨트랙트에서 이더를 인출하는 함수입니다.
```

우리가 Ownable 컨트랙트를 import 했다고 가정하고 owner와 onlyOwner를 사용하고 있다는 것을 참고합니다.

우리는 transfer 함수를 사용해서 이더를 특정 주소로 전달할 수 있습니다.  
그리고 this.balance는 컨트랙트에 저장되있는 전체 잔액을 반환합니다.  
그러니 100명의 사용자가 우리의 컨트랙트에 1이더를 지불했다면, this.balance는 100이더가 될 것입니다.

우리는 transfer 함수를 써서 특정한 이더리움 주소에 돈을 보낼 수 있습니다.
예를 들어, 만약 누군가 한 아이템에 대해 초과 지불을 했다면, 이더를 msg.sender로 되돌려주는 함수를 만들 수도 있습니다.

```
uint itemFee = 0.001 ether;
msg.sender.transfer(msg.value - itemFee);
```

혹은 구매자와 판매자가 존재하는 컨트랙트에서, 판매자의 주소를 storage에 저장하고, 누군가 판매자의 아이템을 구매하면 구매자로부터 받은 요금을 그에게 전달할 수 도 있습니다.

```
seller.transfer(msg.value);
```

### 4. keccak256을 통한 난수 생성

```
// Generate a random number between 1 and 100:
uint randNonce = 0;
uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
randNonce++;
uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
```

이 예시에서는 now의 타임스탬프 값, msg.sender, 증가하는 nonce(딱 한 번만 사용되는 숫자, 즉 똑같은 입력으로 두 번 이상 동일한 해시 함수를 실행할 수 없게 함)를 받고 있습니다.
그리고서 keccak을 사용하여 이 입력들을 임의의 해시 값으로 변환하고, 변환한 해시 값을 uint로 바꾼 후, % 100을 써서 마지막 2자리 숫자만 받도록 했습니다. 이를 통해 0과 99 사이의 완전한 난수를 얻을 수 있습니다.

1. 정직하지 않은 노드의 공격에 취약한 점  
   이더리움에서 컨트랙트의 함수를 실행하면 트랜잭션(transaction)으로서 네트워크의 노드 하나 혹은 여러 노드에 실행을 알리게 됩니다.  
   그 후 네트워크의 노드들은 여러 개의 트랜잭션을 모으고, 작업 증명으로 알려진 계산이 매우 복잡한 수학적 문제를 먼저 풀기 위한 시도를 하게 됩니다.  
   그리고서 해당 트랜잭션 그룹을 그들의 작업 증명(PoW)과 함께 블록으로 네트워크에 배포하게 됩니다.

   한 노드가 어떤 PoW를 풀면, 다른 노드들은 그 PoW를 풀려는 시도를 멈추고 해당 노드가 보낸 트랜잭션 목록이 유효한 것인지 검증합니다.  
   유효하다면 해당 블록을 받아들이고 다음 블록을 풀기 시작합니다.  
   이것이 우리의 난수 함수를 취약하게 만듭니다.

   우리가 동전 던지기 컨트랙트를 사용한다고 가정해봅시다. 앞면이 나오면 돈이 두 배가 되고, 뒷면이 나오면 모두 다 잃는 것입니다. 앞뒷면을 결정할 때 위에서 본 난수 함수를 사용한다고 가정해봅시다.  
   우리가 만약 노드를 실행하고 있다면, 오직 우리의 노드에만 트랜잭션을 알리고 이것을 공유하지 않을 수 있습니다. 그 후 우리가 이기는지 확인하기 위해 동전 던지기 함수를 실행할 수 있는데  
   만약 진다면, 우리가 풀고 있는 다음 블록에 해당 트랜잭션을 포함하지 않는 것을 선택할 수 있습니다. 결국 동전 던지기에서 이기고 다음 블록을 풀 때까지 무한대로 반복해서 우리는 이득을 볼 수 있습니다.

2. 이더리움에서는 어떻게 난수를 안전하게 만들어 낼 수 있을까?  
   oracle(이더리움 외부에서 데이터를 받아오는 안전한 방법 중 하나)을 사용해서 블록체인 밖에서 안전한 난수를 만드는 방법을 사용 할 수 있습니다.

### 5.
